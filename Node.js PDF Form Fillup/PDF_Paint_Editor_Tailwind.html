<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PDF Paint Editor (Tailwind)</title>
    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <!-- jsPDF for export back to PDF (raster fallback) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- pdf-lib for vector PDF editing (preserve original PDF text) -->
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  </head>
  <body class="bg-slate-50 min-h-screen text-slate-800">
    <div class="max-w-6xl mx-auto p-6">
      <h1 class="text-2xl font-semibold mb-4">PDF Paint Editor (Tailwind)</h1>

      <div class="flex gap-4 mb-4 items-start">
        <div class="bg-white p-4 rounded shadow w-72">
          <label class="block text-sm font-medium mb-2">Open PDF</label>
          <input id="fileInput" type="file" accept="application/pdf" class="block w-full text-sm text-slate-600" />

          <div class="mt-4">
            <label class="block text-sm font-medium mb-2">Tool</label>
            <div class="grid grid-cols-2 gap-2">
              <button id="penBtn" class="tool-btn flex-1 py-2 rounded bg-indigo-600 text-white">Pen</button>
              <button id="eraserBtn" class="tool-btn flex-1 py-2 rounded bg-slate-200">Eraser</button>
              <button id="lineBtn" class="tool-btn flex-1 py-2 rounded bg-slate-200">Line</button>
              <button id="squareBtn" class="tool-btn flex-1 py-2 rounded bg-slate-200">Square</button>
              <button id="rectangleBtn" class="tool-btn flex-1 py-2 rounded bg-slate-200">Rectangle</button>
              <button id="circleBtn" class="tool-btn flex-1 py-2 rounded bg-slate-200">Circle</button>
              <button id="verticalBtn" class="tool-btn flex-1 py-2 rounded bg-slate-200">Vertical</button>
              <button id="horizontalBtn" class="tool-btn flex-1 py-2 rounded bg-slate-200">Horizontal</button>
            </div>
          </div>

          <div class="mt-4">
            <label class="block text-sm font-medium mb-2">Color</label>
            <input id="colorInput" type="color" value="#ff0000" class="w-full h-10 p-1" />
          </div>

          <div class="mt-4">
            <label class="block text-sm font-medium mb-2">Size</label>
            <input id="sizeInput" type="range" min="1" max="50" value="4" class="w-full" />
          </div>

          <div class="mt-4 flex gap-2">
            <button id="undoBtn" class="w-full py-2 rounded bg-yellow-400 text-white">Undo</button>
            <button id="clearBtn" class="w-full py-2 rounded bg-red-500 text-white">Clear</button>
          </div>

          <div class="mt-4 flex gap-2">
            <button id="savePngBtn" class="w-full py-2 rounded bg-green-600 text-white">Save PNG</button>
            <button id="exportPdfBtn" class="w-full py-2 rounded bg-blue-600 text-white">Export PDF</button>
          </div>

          <p class="mt-3 text-xs text-slate-500">Notes: This is a single-page editor. For multi-page, load and navigate pages manually.</p>
        </div>

        <div class="flex-1 bg-white p-4 rounded shadow">
          <div id="viewerContainer" class="relative border border-slate-200 rounded overflow-auto" style="height:78vh;">
            <!-- PDF canvas -->
            <canvas id="pdfCanvas" class="block mx-auto bg-white"></canvas>
            <!-- Drawing canvas sits on top -->
            <canvas id="drawCanvas" class="absolute top-0 left-0 pointer-events-auto"></canvas>
          </div>
        </div>
      </div>

      <p class="text-sm text-slate-600">Usage: Open a PDF, select a tool (Pen, Eraser, Line, Square, Rectangle, Circle, Vertical, Horizontal), draw with mouse/touch, change color and size, Undo or Clear, then save PNG or export PDF with vector annotations. Eraser removes freehand strokes and shapes it overlaps.</p>
    </div>

    <script>
      // Basic PDF.js setup
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

      const fileInput = document.getElementById('fileInput');
      const pdfCanvas = document.getElementById('pdfCanvas');
      const drawCanvas = document.getElementById('drawCanvas');
      const viewerContainer = document.getElementById('viewerContainer');

      // Helper functions for eraser on shapes
      function getStrokeBbox(stroke) {
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const p of stroke.points) {
          minX = Math.min(minX, p.x);
          maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y);
          maxY = Math.max(maxY, p.y);
        }
        return { minX, maxX, minY, maxY };
      }

      function getShapeBbox(shape) {
        const { start, end } = shape;
        let minX, maxX, minY, maxY;
        if (shape.type === 'line' || shape.type === 'vertical' || shape.type === 'horizontal') {
          minX = Math.min(start.x, end.x);
          maxX = Math.max(start.x, end.x);
          minY = Math.min(start.y, end.y);
          maxY = Math.max(start.y, end.y);
        } else if (shape.type === 'rectangle' || shape.type === 'square') {
          const width = end.x - start.x;
          const height = end.y - start.y;
          minX = Math.min(start.x, start.x + width);
          maxX = Math.max(start.x, start.x + width);
          minY = Math.min(start.y, start.y + height);
          maxY = Math.max(start.y, start.y + height);
        } else if (shape.type === 'circle') {
          const radius = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2);
          minX = start.x - radius;
          maxX = start.x + radius;
          minY = start.y - radius;
          maxY = start.y + radius;
        }
        return { minX, maxX, minY, maxY };
      }

      function bboxesOverlap(bbox1, bbox2) {
        return !(bbox1.maxX < bbox2.minX || bbox1.minX > bbox2.maxX ||
                 bbox1.maxY < bbox2.minY || bbox1.minY > bbox2.maxY);
      }
      const eraserBtn = document.getElementById('eraserBtn');
      const lineBtn = document.getElementById('lineBtn');
      const squareBtn = document.getElementById('squareBtn');
      const rectangleBtn = document.getElementById('rectangleBtn');
      const circleBtn = document.getElementById('circleBtn');
      const verticalBtn = document.getElementById('verticalBtn');
      const horizontalBtn = document.getElementById('horizontalBtn');
      const colorInput = document.getElementById('colorInput');
      const sizeInput = document.getElementById('sizeInput');
      const undoBtn = document.getElementById('undoBtn');
      const clearBtn = document.getElementById('clearBtn');
      const savePngBtn = document.getElementById('savePngBtn');
      const exportPdfBtn = document.getElementById('exportPdfBtn');

      let pdfDoc = null;
      let currentPage = 1;
      let scale = 1.5;

      function setActiveTool(tool) {
        const buttons = [penBtn, eraserBtn, lineBtn, squareBtn, rectangleBtn, circleBtn, verticalBtn, horizontalBtn];
        buttons.forEach(btn => {
          btn.classList.remove('bg-indigo-600', 'text-white');
          btn.classList.add('bg-slate-200');
        });
        const activeBtn = document.getElementById(tool + 'Btn');
        activeBtn.classList.add('bg-indigo-600', 'text-white');
        activeBtn.classList.remove('bg-slate-200');
        drawState.tool = tool;
      }

      penBtn.addEventListener('click', () => setActiveTool('pen'));
      eraserBtn.addEventListener('click', () => setActiveTool('eraser'));
      lineBtn.addEventListener('click', () => setActiveTool('line'));
      squareBtn.addEventListener('click', () => setActiveTool('square'));
      rectangleBtn.addEventListener('click', () => setActiveTool('rectangle'));
      circleBtn.addEventListener('click', () => setActiveTool('circle'));
      verticalBtn.addEventListener('click', () => setActiveTool('vertical'));
      horizontalBtn.addEventListener('click', () => setActiveTool('horizontal'));

      let originalPdfArrayBuffer = null;

      fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const arrayBuffer = await file.arrayBuffer();
        // keep original for vector export
        originalPdfArrayBuffer = arrayBuffer;
        const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
        pdfDoc = await loadingTask.promise;
        currentPage = 1;
        await renderPage(currentPage);
      });

      async function renderPage(pageNum) {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale });

        // set canvas size
        pdfCanvas.width = Math.floor(viewport.width);
        pdfCanvas.height = Math.floor(viewport.height);

        const context = pdfCanvas.getContext('2d');
        const renderContext = {
          canvasContext: context,
          viewport,
        };

        await page.render(renderContext).promise;

        // position draw canvas over pdfCanvas
        drawCanvas.width = pdfCanvas.width;
        drawCanvas.height = pdfCanvas.height;
        drawCanvas.style.width = pdfCanvas.style.width = (pdfCanvas.width) + 'px';
        drawCanvas.style.height = pdfCanvas.style.height = (pdfCanvas.height) + 'px';
        drawCanvas.style.top = pdfCanvas.offsetTop + 'px';
        drawCanvas.style.left = pdfCanvas.offsetLeft + 'px';

        // reset drawing state
        clearAllStrokes();
      }

      // Drawing state
      const drawState = {
        drawing: false,
        tool: 'pen',
        color: colorInput.value,
        size: parseInt(sizeInput.value, 10),
        strokes: [], // each stroke: {tool, color, size, points: [{x,y}]}
        shapes: [], // each shape: {type, start: {x,y}, end: {x,y}, color, size}
        currentShape: null, // for preview
      };

      colorInput.addEventListener('input', (e) => drawState.color = e.target.value);
      sizeInput.addEventListener('input', (e) => drawState.size = parseInt(e.target.value, 10));

      function getCanvasPoint(evt) {
        const rect = drawCanvas.getBoundingClientRect();
        const x = (evt.clientX - rect.left) * (drawCanvas.width / rect.width);
        const y = (evt.clientY - rect.top) * (drawCanvas.height / rect.height);
        return { x, y };
      }

      drawCanvas.addEventListener('pointerdown', (e) => {
        drawCanvas.setPointerCapture(e.pointerId);
        drawState.drawing = true;
        const p = getCanvasPoint(e);
        if (drawState.tool === 'pen' || drawState.tool === 'eraser') {
          const stroke = { tool: drawState.tool, color: drawState.color, size: drawState.size, points: [p] };
          drawState.strokes.push(stroke);
        } else {
          // shape tools
          drawState.currentShape = { type: drawState.tool, start: p, end: p, color: drawState.color, size: drawState.size };
        }
        redraw();
      });

      drawCanvas.addEventListener('pointermove', (e) => {
        if (!drawState.drawing) return;
        const p = getCanvasPoint(e);
        if (drawState.tool === 'pen' || drawState.tool === 'eraser') {
          const stroke = drawState.strokes[drawState.strokes.length - 1];
          stroke.points.push(p);
          redraw();
        } else {
          // update shape end
          if (drawState.tool === 'vertical') {
            p.x = drawState.currentShape.start.x;
          } else if (drawState.tool === 'horizontal') {
            p.y = drawState.currentShape.start.y;
          }
          drawState.currentShape.end = p;
          redraw();
        }
      });

      drawCanvas.addEventListener('pointerup', (e) => {
        drawCanvas.releasePointerCapture(e.pointerId);
        drawState.drawing = false;
        if (drawState.tool !== 'pen' && drawState.tool !== 'eraser') {
          // add shape
          drawState.shapes.push(drawState.currentShape);
          drawState.currentShape = null;
        } else if (drawState.tool === 'eraser') {
          // check for erasing shapes
          const eraserStroke = drawState.strokes[drawState.strokes.length - 1];
          const eraserBbox = getStrokeBbox(eraserStroke);
          drawState.shapes = drawState.shapes.filter(shape => !bboxesOverlap(eraserBbox, getShapeBbox(shape)));
          redraw();
        }
      });

      function redraw() {
        const ctx = drawCanvas.getContext('2d');
        ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        // draw strokes
        for (const stroke of drawState.strokes) {
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.lineWidth = stroke.size;
          if (stroke.tool === 'eraser') {
            ctx.globalCompositeOperation = 'destination-out';
            ctx.strokeStyle = 'rgba(0,0,0,1)';
          } else {
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = stroke.color;
          }

          ctx.beginPath();
          const pts = stroke.points;
          if (pts.length === 1) {
            ctx.moveTo(pts[0].x, pts[0].y);
            ctx.lineTo(pts[0].x + 0.01, pts[0].y + 0.01);
            ctx.stroke();
          } else {
            ctx.moveTo(pts[0].x, pts[0].y);
            for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
            ctx.stroke();
          }
        }
        // draw shapes
        ctx.globalCompositeOperation = 'source-over';
        for (const shape of drawState.shapes) {
          drawShape(ctx, shape);
        }
        // draw current shape preview
        if (drawState.currentShape) {
          drawShape(ctx, drawState.currentShape);
        }
      }

      function drawShape(ctx, shape) {
        ctx.strokeStyle = shape.color;
        ctx.lineWidth = shape.size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        const { start, end } = shape;
        switch (shape.type) {
          case 'line':
          case 'vertical':
          case 'horizontal':
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
            break;
          case 'rectangle':
            const width = end.x - start.x;
            const height = end.y - start.y;
            ctx.strokeRect(start.x, start.y, width, height);
            break;
          case 'square':
            const side = Math.min(Math.abs(end.x - start.x), Math.abs(end.y - start.y));
            const dirX = end.x > start.x ? 1 : -1;
            const dirY = end.y > start.y ? 1 : -1;
            ctx.strokeRect(start.x, start.y, side * dirX, side * dirY);
            break;
          case 'circle':
            const radius = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2);
            ctx.beginPath();
            ctx.arc(start.x, start.y, radius, 0, 2 * Math.PI);
            ctx.stroke();
            break;
        }
      }

      undoBtn.addEventListener('click', () => {
        if (drawState.shapes.length > 0) {
          drawState.shapes.pop();
        } else if (drawState.strokes.length > 0) {
          drawState.strokes.pop();
        }
        redraw();
      });

      clearBtn.addEventListener('click', () => clearAllStrokes());

      function clearAllStrokes() {
        drawState.strokes = [];
        drawState.shapes = [];
        const ctx = drawCanvas.getContext('2d');
        ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      }

      savePngBtn.addEventListener('click', () => {
        // flatten pdfCanvas + drawCanvas to single PNG
        const w = pdfCanvas.width, h = pdfCanvas.height;
        const out = document.createElement('canvas');
        out.width = w; out.height = h;
        const octx = out.getContext('2d');
        octx.drawImage(pdfCanvas, 0, 0);
        octx.drawImage(drawCanvas, 0, 0);
        const dataUrl = out.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = 'edited-page.png';
        a.click();
      });

      exportPdfBtn.addEventListener('click', async () => {
        // Preferred: use pdf-lib to load the original PDF and draw vector strokes on top
        if (!originalPdfArrayBuffer) {
          alert('Please load a PDF first');
          return;
        }

        try {
          const { PDFDocument, rgb } = PDFLib;

          const pdfDocLib = await PDFDocument.load(originalPdfArrayBuffer);
          const pages = pdfDocLib.getPages();
          const page = pages[0];

          // PDF page size in points
          const { width: pdfWidth, height: pdfHeight } = page.getSize();

          // Canvas size in pixels
          const canvasW = pdfCanvas.width;
          const canvasH = pdfCanvas.height;

          // helper: convert canvas px -> pdf points (and flip Y)
          const toPdfPoint = (pt) => {
            return {
              x: pt.x * (pdfWidth / canvasW),
              y: pdfHeight - pt.y * (pdfHeight / canvasH),
            };
          };

          function hexToRgbNormalized(hex) {
            const h = hex.replace('#','');
            const bigint = parseInt(h, 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return { r: r/255, g: g/255, b: b/255 };
          }

          // Separate pen strokes and eraser strokes
          const penStrokes = drawState.strokes.filter(s => s.tool === 'pen');
          const eraserStrokes = drawState.strokes.filter(s => s.tool === 'eraser');

          // If there are eraser strokes, remove pen points near eraser points (approximate)
          function isPointErased(pt) {
            for (const er of eraserStrokes) {
              for (const ept of er.points) {
                const dx = pt.x - ept.x;
                const dy = pt.y - ept.y;
                const dist2 = dx*dx + dy*dy;
                const r = er.size * 1.0; // eraser radius in px
                if (dist2 <= r*r) return true;
              }
            }
            return false;
          }

          // Build cleaned stroke segments (split when points removed)
          const cleanedSegments = [];
          for (const stroke of penStrokes) {
            const pts = stroke.points;
            let segment = [];
            for (let i=0;i<pts.length;i++) {
              const p = pts[i];
              if (!isPointErased(p)) {
                segment.push(p);
              } else {
                if (segment.length >= 2) cleanedSegments.push({ points: segment.slice(), color: stroke.color, size: stroke.size });
                segment = [];
              }
            }
            if (segment.length >= 2) cleanedSegments.push({ points: segment.slice(), color: stroke.color, size: stroke.size });
          }

          // Draw each segment to the PDF as many small line segments
          for (const seg of cleanedSegments) {
            const col = hexToRgbNormalized(seg.color || '#000000');
            const thickness = seg.size * (pdfWidth / canvasW);
            for (let i=1;i<seg.points.length;i++) {
              const a = toPdfPoint(seg.points[i-1]);
              const b = toPdfPoint(seg.points[i]);
              page.drawLine({
                start: { x: a.x, y: a.y },
                end: { x: b.x, y: b.y },
                thickness,
                color: rgb(col.r, col.g, col.b),
                // round caps are not directly supported; thickness provides decent look
              });
            }
          }

          // Draw shapes
          for (const shape of drawState.shapes) {
            const col = hexToRgbNormalized(shape.color || '#000000');
            const thickness = shape.size * (pdfWidth / canvasW);
            const s = toPdfPoint(shape.start);
            const e = toPdfPoint(shape.end);
            switch (shape.type) {
              case 'line':
              case 'vertical':
              case 'horizontal':
                page.drawLine({
                  start: s,
                  end: e,
                  thickness,
                  color: rgb(col.r, col.g, col.b),
                });
                break;
              case 'rectangle':
                const width = e.x - s.x;
                const height = e.y - s.y;
                page.drawRectangle({
                  x: s.x,
                  y: s.y,
                  width,
                  height,
                  borderColor: rgb(col.r, col.g, col.b),
                  borderWidth: thickness,
                });
                break;
              case 'square':
                const side = Math.min(Math.abs(e.x - s.x), Math.abs(e.y - s.y));
                const dirX = e.x > s.x ? 1 : -1;
                const dirY = e.y > s.y ? 1 : -1;
                page.drawRectangle({
                  x: s.x,
                  y: s.y,
                  width: side * dirX,
                  height: side * dirY,
                  borderColor: rgb(col.r, col.g, col.b),
                  borderWidth: thickness,
                });
                break;
              case 'circle':
                const radius = Math.sqrt((e.x - s.x) ** 2 + (e.y - s.y) ** 2);
                page.drawCircle({
                  x: s.x,
                  y: s.y,
                  size: radius,
                  borderColor: rgb(col.r, col.g, col.b),
                  borderWidth: thickness,
                });
                break;
            }
          }

          const modifiedPdfBytes = await pdfDocLib.save();
          const blob = new Blob([modifiedPdfBytes], { type: 'application/pdf' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'edited-page-vector.pdf';
          a.click();
          URL.revokeObjectURL(url);
        } catch (err) {
          console.error('Vector export failed, falling back to raster export', err);
          // Fallback: raster export but use PNG (lossless) and higher resolution
          const { jsPDF } = window.jspdf;
          const upscale = 2; // increase rendering resolution for better quality
          const w = pdfCanvas.width * upscale, h = pdfCanvas.height * upscale;
          const out = document.createElement('canvas');
          out.width = w; out.height = h;
          const octx = out.getContext('2d');
          // draw scaled
          octx.drawImage(pdfCanvas, 0, 0, w, h);
          octx.drawImage(drawCanvas, 0, 0, w, h);
          const imgData = out.toDataURL('image/png');
          const pdf = new jsPDF({ unit: 'px', format: [w, h] });
          pdf.addImage(imgData, 'PNG', 0, 0, w, h);
          pdf.save('edited-page.pdf');
        }
      });

      // initialize default tool
      setActiveTool('pen');
    </script>
  </body>
</html>
