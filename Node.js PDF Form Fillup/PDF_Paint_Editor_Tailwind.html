<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PDF Paint Editor (Tailwind)</title>
    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <!-- jsPDF for export back to PDF (raster fallback) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- pdf-lib for vector PDF editing (preserve original PDF text) -->
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  </head>
  <body class="bg-slate-50 min-h-screen text-slate-800">
    <div class="max-w-6xl mx-auto p-6">
      <h1 class="text-2xl font-semibold mb-4">PDF Paint Editor (Tailwind)</h1>

      <div class="flex gap-4 mb-4 items-start">
        <div class="bg-white p-4 rounded shadow w-72">
          <label class="block text-sm font-medium mb-2">Open PDF</label>
          <input id="fileInput" type="file" accept="application/pdf" class="block w-full text-sm text-slate-600" />

          <div class="mt-4">
            <label class="block text-sm font-medium mb-2">Tool</label>
            <div class="flex gap-2">
              <button id="penBtn" class="tool-btn flex-1 py-2 rounded bg-indigo-600 text-white">Pen</button>
              <button id="eraserBtn" class="tool-btn flex-1 py-2 rounded bg-slate-200">Eraser</button>
            </div>
          </div>

          <div class="mt-4">
            <label class="block text-sm font-medium mb-2">Color</label>
            <input id="colorInput" type="color" value="#ff0000" class="w-full h-10 p-1" />
          </div>

          <div class="mt-4">
            <label class="block text-sm font-medium mb-2">Size</label>
            <input id="sizeInput" type="range" min="1" max="50" value="4" class="w-full" />
          </div>

          <div class="mt-4 flex gap-2">
            <button id="undoBtn" class="w-full py-2 rounded bg-yellow-400 text-white">Undo</button>
            <button id="clearBtn" class="w-full py-2 rounded bg-red-500 text-white">Clear</button>
          </div>

          <div class="mt-4 flex gap-2">
            <button id="savePngBtn" class="w-full py-2 rounded bg-green-600 text-white">Save PNG</button>
            <button id="exportPdfBtn" class="w-full py-2 rounded bg-blue-600 text-white">Export PDF</button>
          </div>

          <p class="mt-3 text-xs text-slate-500">Notes: This is a single-page editor. For multi-page, load and navigate pages manually.</p>
        </div>

        <div class="flex-1 bg-white p-4 rounded shadow">
          <div id="viewerContainer" class="relative border border-slate-200 rounded overflow-auto" style="height:78vh;">
            <!-- PDF canvas -->
            <canvas id="pdfCanvas" class="block mx-auto bg-white"></canvas>
            <!-- Drawing canvas sits on top -->
            <canvas id="drawCanvas" class="absolute top-0 left-0 pointer-events-auto"></canvas>
          </div>
        </div>
      </div>

      <p class="text-sm text-slate-600">Usage: Open a PDF, draw with Pen, use Eraser to clear strokes, Undo or Clear, then save PNG or export a new PDF with drawings flattened.</p>
    </div>

    <script>
      // Basic PDF.js setup
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

      const fileInput = document.getElementById('fileInput');
      const pdfCanvas = document.getElementById('pdfCanvas');
      const drawCanvas = document.getElementById('drawCanvas');
      const viewerContainer = document.getElementById('viewerContainer');

      const penBtn = document.getElementById('penBtn');
      const eraserBtn = document.getElementById('eraserBtn');
      const colorInput = document.getElementById('colorInput');
      const sizeInput = document.getElementById('sizeInput');
      const undoBtn = document.getElementById('undoBtn');
      const clearBtn = document.getElementById('clearBtn');
      const savePngBtn = document.getElementById('savePngBtn');
      const exportPdfBtn = document.getElementById('exportPdfBtn');

      let pdfDoc = null;
      let currentPage = 1;
      let scale = 1.5;

      function setActiveTool(tool) {
        if (tool === 'pen') {
          penBtn.classList.add('bg-indigo-600', 'text-white');
          penBtn.classList.remove('bg-slate-200', 'text-slate-800');
          eraserBtn.classList.remove('bg-indigo-600', 'text-white');
          eraserBtn.classList.add('bg-slate-200');
          drawState.tool = 'pen';
        } else {
          eraserBtn.classList.add('bg-indigo-600', 'text-white');
          eraserBtn.classList.remove('bg-slate-200');
          penBtn.classList.remove('bg-indigo-600', 'text-white');
          penBtn.classList.add('bg-slate-200');
          drawState.tool = 'eraser';
        }
      }

      penBtn.addEventListener('click', () => setActiveTool('pen'));
      eraserBtn.addEventListener('click', () => setActiveTool('eraser'));

      let originalPdfArrayBuffer = null;

      fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const arrayBuffer = await file.arrayBuffer();
        // keep original for vector export
        originalPdfArrayBuffer = arrayBuffer;
        const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
        pdfDoc = await loadingTask.promise;
        currentPage = 1;
        await renderPage(currentPage);
      });

      async function renderPage(pageNum) {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale });

        // set canvas size
        pdfCanvas.width = Math.floor(viewport.width);
        pdfCanvas.height = Math.floor(viewport.height);

        const context = pdfCanvas.getContext('2d');
        const renderContext = {
          canvasContext: context,
          viewport,
        };

        await page.render(renderContext).promise;

        // position draw canvas over pdfCanvas
        drawCanvas.width = pdfCanvas.width;
        drawCanvas.height = pdfCanvas.height;
        drawCanvas.style.width = pdfCanvas.style.width = (pdfCanvas.width) + 'px';
        drawCanvas.style.height = pdfCanvas.style.height = (pdfCanvas.height) + 'px';
        drawCanvas.style.top = pdfCanvas.offsetTop + 'px';
        drawCanvas.style.left = pdfCanvas.offsetLeft + 'px';

        // reset drawing state
        clearAllStrokes();
      }

      // Drawing state
      const drawState = {
        drawing: false,
        tool: 'pen',
        color: colorInput.value,
        size: parseInt(sizeInput.value, 10),
        strokes: [], // each stroke: {tool, color, size, points: [{x,y}]}
      };

      colorInput.addEventListener('input', (e) => drawState.color = e.target.value);
      sizeInput.addEventListener('input', (e) => drawState.size = parseInt(e.target.value, 10));

      function getCanvasPoint(evt) {
        const rect = drawCanvas.getBoundingClientRect();
        const x = (evt.clientX - rect.left) * (drawCanvas.width / rect.width);
        const y = (evt.clientY - rect.top) * (drawCanvas.height / rect.height);
        return { x, y };
      }

      drawCanvas.addEventListener('pointerdown', (e) => {
        drawCanvas.setPointerCapture(e.pointerId);
        drawState.drawing = true;
        const p = getCanvasPoint(e);
        const stroke = { tool: drawState.tool, color: drawState.color, size: drawState.size, points: [p] };
        drawState.strokes.push(stroke);
        redraw();
      });

      drawCanvas.addEventListener('pointermove', (e) => {
        if (!drawState.drawing) return;
        const p = getCanvasPoint(e);
        const stroke = drawState.strokes[drawState.strokes.length - 1];
        stroke.points.push(p);
        redraw();
      });

      drawCanvas.addEventListener('pointerup', (e) => {
        drawCanvas.releasePointerCapture(e.pointerId);
        drawState.drawing = false;
      });

      function redraw() {
        const ctx = drawCanvas.getContext('2d');
        ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        for (const stroke of drawState.strokes) {
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.lineWidth = stroke.size;
          if (stroke.tool === 'eraser') {
            ctx.globalCompositeOperation = 'destination-out';
            ctx.strokeStyle = 'rgba(0,0,0,1)';
          } else {
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = stroke.color;
          }

          ctx.beginPath();
          const pts = stroke.points;
          if (pts.length === 1) {
            ctx.moveTo(pts[0].x, pts[0].y);
            ctx.lineTo(pts[0].x + 0.01, pts[0].y + 0.01);
            ctx.stroke();
          } else {
            ctx.moveTo(pts[0].x, pts[0].y);
            for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
            ctx.stroke();
          }
        }
      }

      undoBtn.addEventListener('click', () => {
        drawState.strokes.pop();
        redraw();
      });

      clearBtn.addEventListener('click', () => clearAllStrokes());

      function clearAllStrokes() {
        drawState.strokes = [];
        const ctx = drawCanvas.getContext('2d');
        ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      }

      savePngBtn.addEventListener('click', () => {
        // flatten pdfCanvas + drawCanvas to single PNG
        const w = pdfCanvas.width, h = pdfCanvas.height;
        const out = document.createElement('canvas');
        out.width = w; out.height = h;
        const octx = out.getContext('2d');
        octx.drawImage(pdfCanvas, 0, 0);
        octx.drawImage(drawCanvas, 0, 0);
        const dataUrl = out.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = 'edited-page.png';
        a.click();
      });

      exportPdfBtn.addEventListener('click', async () => {
        // Preferred: use pdf-lib to load the original PDF and draw vector strokes on top
        if (!originalPdfArrayBuffer) {
          alert('Please load a PDF first');
          return;
        }

        try {
          const { PDFDocument, rgb } = PDFLib;

          const pdfDocLib = await PDFDocument.load(originalPdfArrayBuffer);
          const pages = pdfDocLib.getPages();
          const page = pages[0];

          // PDF page size in points
          const { width: pdfWidth, height: pdfHeight } = page.getSize();

          // Canvas size in pixels
          const canvasW = pdfCanvas.width;
          const canvasH = pdfCanvas.height;

          // helper: convert canvas px -> pdf points (and flip Y)
          const toPdfPoint = (pt) => {
            return {
              x: pt.x * (pdfWidth / canvasW),
              y: pdfHeight - pt.y * (pdfHeight / canvasH),
            };
          };

          function hexToRgbNormalized(hex) {
            const h = hex.replace('#','');
            const bigint = parseInt(h, 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return { r: r/255, g: g/255, b: b/255 };
          }

          // Separate pen strokes and eraser strokes
          const penStrokes = drawState.strokes.filter(s => s.tool === 'pen');
          const eraserStrokes = drawState.strokes.filter(s => s.tool === 'eraser');

          // If there are eraser strokes, remove pen points near eraser points (approximate)
          function isPointErased(pt) {
            for (const er of eraserStrokes) {
              for (const ept of er.points) {
                const dx = pt.x - ept.x;
                const dy = pt.y - ept.y;
                const dist2 = dx*dx + dy*dy;
                const r = er.size * 1.0; // eraser radius in px
                if (dist2 <= r*r) return true;
              }
            }
            return false;
          }

          // Build cleaned stroke segments (split when points removed)
          const cleanedSegments = [];
          for (const stroke of penStrokes) {
            const pts = stroke.points;
            let segment = [];
            for (let i=0;i<pts.length;i++) {
              const p = pts[i];
              if (!isPointErased(p)) {
                segment.push(p);
              } else {
                if (segment.length >= 2) cleanedSegments.push({ points: segment.slice(), color: stroke.color, size: stroke.size });
                segment = [];
              }
            }
            if (segment.length >= 2) cleanedSegments.push({ points: segment.slice(), color: stroke.color, size: stroke.size });
          }

          // Draw each segment to the PDF as many small line segments
          for (const seg of cleanedSegments) {
            const col = hexToRgbNormalized(seg.color || '#000000');
            const thickness = seg.size * (pdfWidth / canvasW);
            for (let i=1;i<seg.points.length;i++) {
              const a = toPdfPoint(seg.points[i-1]);
              const b = toPdfPoint(seg.points[i]);
              page.drawLine({
                start: { x: a.x, y: a.y },
                end: { x: b.x, y: b.y },
                thickness,
                color: rgb(col.r, col.g, col.b),
                // round caps are not directly supported; thickness provides decent look
              });
            }
          }

          const modifiedPdfBytes = await pdfDocLib.save();
          const blob = new Blob([modifiedPdfBytes], { type: 'application/pdf' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'edited-page-vector.pdf';
          a.click();
          URL.revokeObjectURL(url);
        } catch (err) {
          console.error('Vector export failed, falling back to raster export', err);
          // Fallback: raster export but use PNG (lossless) and higher resolution
          const { jsPDF } = window.jspdf;
          const upscale = 2; // increase rendering resolution for better quality
          const w = pdfCanvas.width * upscale, h = pdfCanvas.height * upscale;
          const out = document.createElement('canvas');
          out.width = w; out.height = h;
          const octx = out.getContext('2d');
          // draw scaled
          octx.drawImage(pdfCanvas, 0, 0, w, h);
          octx.drawImage(drawCanvas, 0, 0, w, h);
          const imgData = out.toDataURL('image/png');
          const pdf = new jsPDF({ unit: 'px', format: [w, h] });
          pdf.addImage(imgData, 'PNG', 0, 0, w, h);
          pdf.save('edited-page.pdf');
        }
      });

      // initialize default tool
      setActiveTool('pen');
    </script>
  </body>
</html>
